diff --git a/node_modules/@shieldswap/l1-transact/dist/lib/DeployerCached.js b/node_modules/@shieldswap/l1-transact/dist/lib/DeployerCached.js
index 5334cf8..fa8493b 100644
--- a/node_modules/@shieldswap/l1-transact/dist/lib/DeployerCached.js
+++ b/node_modules/@shieldswap/l1-transact/dist/lib/DeployerCached.js
@@ -1,126 +1,138 @@
-import { explorerUrl } from "./utils.js";
+import { explorerUrl } from './utils.js';
 /**
  * Deploys contracts. If a contract is already deployed, it will use the cached address.
  * The cache is stored in localStorage if available.
  * If you update the contract, you should clear the cache using the respective methods.
  */
 export class DeployerCached {
-    DEPLOYED_CONTRACT_CACHE_PREFIX = "deployed_contract_";
-    getContractCacheKey = (/** @type {string} */ name) => `${this.DEPLOYED_CONTRACT_CACHE_PREFIX}${name}`;
-    /**
-     * @template T
-     * @param {string} name
-     * @param {(address: string) => Promise<T>} connect
-     */
-    async getContractCached(name, connect) {
-        const key = this.getContractCacheKey(name);
-        const cachedAddress = storage.getItem(key);
-        if (!cachedAddress) {
-            return undefined;
-        }
-        try {
-            const connected = await connect(cachedAddress);
-            console.log(`Using cached ${name}...`);
-            return connected;
-            // eslint-disable-next-line @typescript-eslint/no-explicit-any
-        }
-        catch ( /** @type {any} */e) {
-            if (e?.message.includes("is not deployed")) {
-                this.clearContractCache(name);
-                return undefined;
-            }
-            throw e;
-        }
+  DEPLOYED_CONTRACT_CACHE_PREFIX = 'deployed_contract_';
+  getContractCacheKey = (/** @type {string} */ name) =>
+    `${this.DEPLOYED_CONTRACT_CACHE_PREFIX}${name}`;
+  /**
+   * @template T
+   * @param {string} name
+   * @param {(address: string) => Promise<T>} connect
+   */
+  async getContractCached(name, connect) {
+    const key = this.getContractCacheKey(name);
+    const cachedAddress = storage.getItem(key);
+    if (!cachedAddress) {
+      return undefined;
     }
-    /**
-     * @template {import('@aztec/aztec.js').Contract} T
-     * @param {string} name
-     * @param {(address: import('@aztec/aztec.js').AztecAddress) => Promise<T>} connect
-     * @param {() => import('ts-essentials').AsyncOrSync<import('@aztec/aztec.js').DeploySentTx<T>>} deploy
-     */
-    async l2DeployContractCached(name, connect, deploy) {
-        const { AztecAddress } = await import("@aztec/aztec.js");
-        name = "l2_" + name;
-        return this.#deployCached(name, (addr) => connect(AztecAddress.fromString(addr)), async () => {
-            const tx = await deploy();
-            console.log(`Deploying ${name} tx hash:`, explorerUrl.tx((await tx.getTxHash()).toString()));
-            const contract = await tx.deployed();
-            console.log(`Deployed ${name} at ${explorerUrl.address(contract.address.toString())}`);
-            return {
-                address: contract.address.toString(),
-                contract,
-            };
-        });
+    try {
+      const connected = await connect(cachedAddress);
+      console.log(`Using cached ${name}...`);
+      return connected;
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    } catch (/** @type {any} */ e) {
+      if (e?.message.includes('is not deployed')) {
+        this.clearContractCache(name);
+        return undefined;
+      }
+      throw e;
     }
-    /**
-     * @template {import('ethers').BaseContract} T
-     * @param {string} name
-     * @param {(address: string) => Promise<T>} connect
-     * @param {() => Promise<T>} deploy
-     */
-    async l1DeployContractCached(name, connect, deploy) {
-        name = "l1_" + name;
-        return this.#deployCached(name, connect, async () => {
-            const contract = await deploy();
-            await contract.waitForDeployment();
-            return {
-                address: await contract.getAddress(),
-                contract,
-            };
-        });
+  }
+  /**
+   * @template {import('@aztec/aztec.js').Contract} T
+   * @param {string} name
+   * @param {(address: import('@aztec/aztec.js').AztecAddress) => Promise<T>} connect
+   * @param {() => import('ts-essentials').AsyncOrSync<import('@aztec/aztec.js').DeploySentTx<T>>} deploy
+   */
+  async l2DeployContractCached(name, connect, deploy) {
+    const { AztecAddress } = await import('@aztec/aztec.js');
+    name = 'l2_' + name;
+    return this.#deployCached(
+      name,
+      (addr) => connect(AztecAddress.fromString(addr)),
+      async () => {
+        const tx = await deploy();
+        console.log(
+          `Deploying ${name} tx hash:`,
+          explorerUrl.tx((await tx.getTxHash()).toString()),
+        );
+        const contract = await tx.deployed();
+        console.log(
+          `Deployed ${name} at ${explorerUrl.address(
+            contract.address.toString(),
+          )}`,
+        );
+        return {
+          address: contract.address.toString(),
+          contract,
+        };
+      },
+    );
+  }
+  /**
+   * @template {import('ethers').BaseContract} T
+   * @param {string} name
+   * @param {(address: string) => Promise<T>} connect
+   * @param {() => Promise<T>} deploy
+   */
+  async l1DeployContractCached(name, connect, deploy) {
+    name = 'l1_' + name;
+    return this.#deployCached(name, connect, async () => {
+      const contract = await deploy();
+      await contract.waitForDeployment();
+      return {
+        address: await contract.getAddress(),
+        contract,
+      };
+    });
+  }
+  /**
+   * @template T
+   * @param {string} name
+   * @param {(address: string) => Promise<T>} connect
+   * @param {() => Promise<{ contract: T, address: string }>} deploy
+   * @returns {Promise<T>}
+   */
+  async #deployCached(name, connect, deploy) {
+    const cached = await this.getContractCached(name, connect);
+    if (cached) {
+      return cached;
     }
-    /**
-     * @template T
-     * @param {string} name
-     * @param {(address: string) => Promise<T>} connect
-     * @param {() => Promise<{ contract: T, address: string }>} deploy
-     * @returns {Promise<T>}
-     */
-    async #deployCached(name, connect, deploy) {
-        const cached = await this.getContractCached(name, connect);
-        if (cached) {
-            return cached;
-        }
-        console.log(`Deploying ${name}...`);
-        const { address, contract } = await deploy();
-        storage.setItem(this.getContractCacheKey(name), address.toString());
-        return contract;
-    }
-    /**
-     * @param {string} name
-     */
-    clearContractCache(name) {
-        storage.removeItem(this.getContractCacheKey(name));
-    }
-    clearContractsCache() {
-        for (const name of Object.keys(storage)) {
-            if (name.startsWith(this.DEPLOYED_CONTRACT_CACHE_PREFIX)) {
-                storage.removeItem(name);
-            }
-        }
+    console.log(`Deploying ${name}...`);
+    const { address, contract } = await deploy();
+    storage.setItem(this.getContractCacheKey(name), address.toString());
+    return contract;
+  }
+  /**
+   * @param {string} name
+   */
+  clearContractCache(name) {
+    storage.removeItem(this.getContractCacheKey(name));
+  }
+  clearContractsCache() {
+    for (const name of Object.keys(storage)) {
+      if (name.startsWith(this.DEPLOYED_CONTRACT_CACHE_PREFIX)) {
+        storage.removeItem(name);
+      }
     }
+  }
 }
 export const deployerCached = new DeployerCached();
 const inMemoryStorage = {
-    _map: new Map(),
-    /**
-     * @param {string} key
-     */
-    getItem(key) {
-        return this._map.get(key);
-    },
-    /**
-     * @param {string} key
-     * @param {string} value
-     */
-    setItem(key, value) {
-        this._map.set(key, value);
-    },
-    /**
-     * @param {string} key
-     */
-    removeItem(key) {
-        this._map.delete(key);
-    },
+  _map: new Map(),
+  /**
+   * @param {string} key
+   */
+  getItem(key) {
+    return this._map.get(key);
+  },
+  /**
+   * @param {string} key
+   * @param {string} value
+   */
+  setItem(key, value) {
+    this._map.set(key, value);
+  },
+  /**
+   * @param {string} key
+   */
+  removeItem(key) {
+    this._map.delete(key);
+  },
 };
-const storage = typeof localStorage !== "undefined" ? localStorage : inMemoryStorage;
+const storage =
+  typeof localStorage !== 'undefined' ? localStorage : inMemoryStorage;
diff --git a/node_modules/@shieldswap/l1-transact/dist/lib/sdk.js b/node_modules/@shieldswap/l1-transact/dist/lib/sdk.js
index ccc5619..7fc5181 100644
--- a/node_modules/@shieldswap/l1-transact/dist/lib/sdk.js
+++ b/node_modules/@shieldswap/l1-transact/dist/lib/sdk.js
@@ -1,550 +1,851 @@
-import * as typechainTypes from "@shieldswap/l1-transact-l1-contracts";
-import { CurrencyAmount } from "@uniswap/sdk-core";
-import { ethers } from "ethers";
-import { compact, omit } from "lodash-es";
-import qs from "qs";
-import { assert } from "ts-essentials";
-import { deployerCached } from "./DeployerCached.js";
-import { explorerUrl, isAddressEqual, sleep } from "./utils.js";
+import * as typechainTypes from '@shieldswap/l1-transact-l1-contracts';
+import { CurrencyAmount } from '@uniswap/sdk-core';
+import { ethers } from 'ethers';
+import { compact, omit } from 'lodash-es';
+import qs from 'qs';
+import { assert } from 'ts-essentials';
+import { deployerCached } from './DeployerCached.js';
+import { explorerUrl, isAddressEqual, sleep } from './utils.js';
 // TODO: fix @shieldswap/l1-transact-l1-contracts module resolution
-const { GenericCallPortal__factory, IERC20__factory, MockERC20__factory, TokenPortal__factory,
-// eslint-disable-next-line @typescript-eslint/no-explicit-any
- } = (typechainTypes?.default ??
-    typechainTypes);
+const {
+  GenericCallPortal__factory,
+  IERC20__factory,
+  MockERC20__factory,
+  TokenPortal__factory,
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+} = typechainTypes?.default ?? typechainTypes;
 const MAX_TOKENS_SIZE = 2;
 export class L1TransactSdk {
-    l1Deployer;
-    l2Deployer;
-    aztecNode;
-    pxe;
-    l2CallPortal;
-    l1CallPortal;
-    l2TokenPortal;
-    l1TokenPortal;
-    constructor(l1Deployer, l2Deployer, aztecNode, pxe, l2CallPortal, l1CallPortal, l2TokenPortal, l1TokenPortal) {
-        this.l1Deployer = l1Deployer;
-        this.l2Deployer = l2Deployer;
-        this.aztecNode = aztecNode;
-        this.pxe = pxe;
-        this.l2CallPortal = l2CallPortal;
-        this.l1CallPortal = l1CallPortal;
-        this.l2TokenPortal = l2TokenPortal;
-        this.l1TokenPortal = l1TokenPortal;
-    }
-    static async deploy({ pxeUrl, l1Deployer, l2Deployer, logger = defaultLogger, }) {
-        const { createPXEClient, createAztecNodeClient, waitForPXE } = await import("@aztec/aztec.js");
-        const pxe = createPXEClient(pxeUrl);
-        await waitForPXE(pxe);
-        const aztecNode = createAztecNodeClient(pxeUrl);
-        const tokenPortalName = "token_portal";
-        const l1TokenPortal = await deployerCached.l1DeployContractCached(tokenPortalName, async (address) => TokenPortal__factory.connect(address, l1Deployer), async () => new TokenPortal__factory(l1Deployer).deploy());
-        const l1ContractAddresses = (await pxe.getNodeInfo()).l1ContractAddresses;
-        const l2TokenPortal = await logger.promise((async () => {
-            const { TokenBridgeContract } = await import("../aztec-contracts/token_bridge/target/TokenBridge.js");
-            const portal = await deployerCached.l2DeployContractCached(tokenPortalName, async (address) => TokenBridgeContract.at(address, l2Deployer), async () => {
-                return TokenBridgeContract.deploy(l2Deployer, await toEthAddress(l1TokenPortal)).send();
-            });
-            if ((await l1TokenPortal.l2BridgeAddress()).toLowerCase() !==
-                portal.address.toString().toLowerCase()) {
-                console.log("initializing L1 token portal...");
-                await (await l1TokenPortal
-                    .connect(l1Deployer)
-                    .initialize(l1ContractAddresses.registryAddress.toString(), portal.address.toString())).wait();
-                console.log("initialized L1 token portal");
-            }
-            return portal;
-        })(), {
-            loading: "Deploying token portal...",
-            success: "Deployed token portal",
-            error: "Failed to deploy token portal",
-        });
-        const callPortalName = "call_portal";
-        const l1CallPortal = await deployerCached.l1DeployContractCached(callPortalName, async (address) => GenericCallPortal__factory.connect(address, l1Deployer), async () => new GenericCallPortal__factory(l1Deployer).deploy());
-        const l2CallPortal = await logger.promise((async () => {
-            const { GenericCallBridgeContract } = await import("../aztec-contracts/generic_call_bridge/target/GenericCallBridge.js");
-            const portal = await deployerCached.l2DeployContractCached(callPortalName, async (address) => GenericCallBridgeContract.at(address, l2Deployer), async () => {
-                return GenericCallBridgeContract.deploy(l2Deployer, await toEthAddress(l1CallPortal)).send();
-            });
-            if ((await l1CallPortal.l2Portal()).toLowerCase() !==
-                portal.address.toString().toLowerCase()) {
-                console.log("initializing L1 generic call portal...");
-                await (await l1CallPortal
-                    .connect(l1Deployer)
-                    .initialize(l1ContractAddresses.registryAddress.toString(), portal.address.toString())).wait();
-                console.log("initialized L1 generic call portal");
-            }
-            return portal;
-        })(), {
-            loading: "Deploying generic call portal...",
-            success: "Deployed generic call portal",
-            error: "Failed to deploy generic call portal",
-        });
-        return new L1TransactSdk(l1Deployer, l2Deployer, aztecNode, pxe, l2CallPortal, l1CallPortal, l2TokenPortal, l1TokenPortal);
-    }
-    /**
-     * @deprecated Use `L1TransactSdk.deploy` instead.
-     */
-    static setup = L1TransactSdk.deploy;
-    async l2MintPrivate(token, to, amount) {
-        const { TxStatus } = await import("@aztec/aztec.js");
-        const { secret, secretHash } = await generateSecretAndHash();
-        const tx = token.methods.mint_private(amount, secretHash).send();
-        const receipt = await tx.wait();
-        assert(receipt.status === TxStatus.MINED);
-        return await this.l2RedeemShield({
-            token,
-            wallet: to,
-            amount,
-            secret,
-            txHash: receipt.txHash,
-        });
-    }
-    async l2MintPublic(token, to, amount) {
-        const { TxStatus } = await import("@aztec/aztec.js");
-        const tx = token.methods.mint_public(to, amount).send();
-        const receipt = await tx.wait();
-        assert(receipt.status === TxStatus.MINED);
-        return receipt;
-    }
-    async l2Balance(token, account) {
-        return (await token
-            .withWallet(account)
-            .methods.balance_of_private(account.getAddress())
-            .simulate());
-    }
-    async l1MintTokens(minter, to, amount) {
-        const tx = await MockERC20__factory.connect(amount.currency.address, minter).mintForTests(to, amount.quotient.toString());
-        return await tx.wait();
-    }
-    async l1Balance(token, account) {
-        return await token.balanceOf(account);
-    }
-    async _addPendingShieldNoteToPXE(token, shieldAmount, secretHash, to, txHash) {
-        const { Note, ExtendedNote, Fr } = await import("@aztec/aztec.js");
-        const { TokenContract } = await import("@aztec/noir-contracts.js/Token");
-        const note = new Note([new Fr(shieldAmount), secretHash]);
-        const extendedNote = new ExtendedNote(note, to, token.address, TokenContract.storage.pending_shields.slot, TokenContract.notes.TransparentNote.id, txHash);
-        await this.pxe.addNote(extendedNote);
-    }
-    async l2RedeemShield({ token, wallet, amount, secret, txHash, }) {
-        const { computeSecretHash } = await import("@aztec/aztec.js");
-        await this._addPendingShieldNoteToPXE(token, amount, computeSecretHash(secret), wallet.getAddress(), txHash);
-        return await token.methods
-            .redeem_shield(wallet.getAddress(), amount, secret)
-            .send()
-            .wait();
-    }
-    async l2RegisterTokenIfNotRegistered(l1Token, l2Token) {
-        if (!l2Token) {
-            assert(l1Token.symbol, "Token.symbol is required to deploy token on L2");
-            l2Token = await this.#l2DeployToken({
-                ...l1Token,
-                symbol: l1Token.symbol,
-            });
-        }
-        const l1TokenAddress = await toEthAddress(l1Token.address);
-        const isRegistered = (await this.l2TokenPortal.methods
-            .token(l1TokenAddress)
-            .simulate()).equals(l2Token.address);
-        if (!isRegistered) {
-            await this.l2TokenPortal.methods
-                .register_token(l1TokenAddress, l2Token)
-                .send()
-                .wait();
+  l1Deployer;
+  l2Deployer;
+  aztecNode;
+  pxe;
+  l2CallPortal;
+  l1CallPortal;
+  l2TokenPortal;
+  l1TokenPortal;
+  constructor(
+    l1Deployer,
+    l2Deployer,
+    aztecNode,
+    pxe,
+    l2CallPortal,
+    l1CallPortal,
+    l2TokenPortal,
+    l1TokenPortal,
+  ) {
+    this.l1Deployer = l1Deployer;
+    this.l2Deployer = l2Deployer;
+    this.aztecNode = aztecNode;
+    this.pxe = pxe;
+    this.l2CallPortal = l2CallPortal;
+    this.l1CallPortal = l1CallPortal;
+    this.l2TokenPortal = l2TokenPortal;
+    this.l1TokenPortal = l1TokenPortal;
+  }
+  static async deploy({
+    pxeUrl,
+    l1Deployer,
+    l2Deployer,
+    logger = defaultLogger,
+  }) {
+    const { createPXEClient, createAztecNodeClient, waitForPXE } = await import(
+      '@aztec/aztec.js'
+    );
+    const pxe = createPXEClient(pxeUrl);
+    await waitForPXE(pxe);
+    const aztecNode = createAztecNodeClient(pxeUrl);
+    const tokenPortalName = 'token_portal';
+    const l1TokenPortal = await deployerCached.l1DeployContractCached(
+      tokenPortalName,
+      async (address) => TokenPortal__factory.connect(address, l1Deployer),
+      async () => new TokenPortal__factory(l1Deployer).deploy(),
+    );
+    const l1ContractAddresses = (await pxe.getNodeInfo()).l1ContractAddresses;
+    const l2TokenPortal = await logger.promise(
+      (async () => {
+        const { TokenBridgeContract } = await import(
+          '../aztec-contracts/token_bridge/target/TokenBridge.js'
+        );
+        const portal = await deployerCached.l2DeployContractCached(
+          tokenPortalName,
+          async (address) => TokenBridgeContract.at(address, l2Deployer),
+          async () => {
+            return TokenBridgeContract.deploy(
+              l2Deployer,
+              await toEthAddress(l1TokenPortal),
+            ).send();
+          },
+        );
+        if (
+          (await l1TokenPortal.l2BridgeAddress()).toLowerCase() !==
+          portal.address.toString().toLowerCase()
+        ) {
+          console.log('initializing L1 token portal...');
+          await (
+            await l1TokenPortal
+              .connect(l1Deployer)
+              .initialize(
+                l1ContractAddresses.registryAddress.toString(),
+                portal.address.toString(),
+              )
+          ).wait();
+          console.log('initialized L1 token portal');
         }
-        const isMinter = await l2Token.methods
-            .is_minter(this.l2TokenPortal.address)
-            .simulate();
-        if (!isMinter) {
-            await l2Token.methods
-                .set_minter(this.l2TokenPortal.address, true)
-                .send()
-                .wait();
+        return portal;
+      })(),
+      {
+        loading: 'Deploying token portal...',
+        success: 'Deployed token portal',
+        error: 'Failed to deploy token portal',
+      },
+    );
+    const callPortalName = 'call_portal';
+    const l1CallPortal = await deployerCached.l1DeployContractCached(
+      callPortalName,
+      async (address) =>
+        GenericCallPortal__factory.connect(address, l1Deployer),
+      async () => new GenericCallPortal__factory(l1Deployer).deploy(),
+    );
+    const l2CallPortal = await logger.promise(
+      (async () => {
+        const { GenericCallBridgeContract } = await import(
+          '../aztec-contracts/generic_call_bridge/target/GenericCallBridge.js'
+        );
+        const portal = await deployerCached.l2DeployContractCached(
+          callPortalName,
+          async (address) => GenericCallBridgeContract.at(address, l2Deployer),
+          async () => {
+            return GenericCallBridgeContract.deploy(
+              l2Deployer,
+              await toEthAddress(l1CallPortal),
+            ).send();
+          },
+        );
+        if (
+          (await l1CallPortal.l2Portal()).toLowerCase() !==
+          portal.address.toString().toLowerCase()
+        ) {
+          console.log('initializing L1 generic call portal...');
+          await (
+            await l1CallPortal
+              .connect(l1Deployer)
+              .initialize(
+                l1ContractAddresses.registryAddress.toString(),
+                portal.address.toString(),
+              )
+          ).wait();
+          console.log('initialized L1 generic call portal');
         }
-        return l2Token;
-    }
-    async #l2DeployToken(token) {
-        const { TokenContract } = await import("@aztec/noir-contracts.js/Token");
-        return await deployerCached.l2DeployContractCached("token_" + token.symbol.toLowerCase(), async (address) => TokenContract.at(address, this.l2Deployer), async () => TokenContract.deploy(this.l2Deployer, this.l2Deployer.getAddress(), token.symbol, token.symbol, token.decimals).send());
-    }
-    async progressRollup() {
-        const { EthAddress, AztecAddress } = await import("@aztec/aztec.js");
-        await sleep(10_000);
-        await this.l2TokenPortal.methods
-            .register_token(EthAddress.random(), AztecAddress.random())
-            .send()
-            .wait();
-        await this.l2TokenPortal.methods
-            .register_token(EthAddress.random(), AztecAddress.random())
-            .send()
-            .wait();
+        return portal;
+      })(),
+      {
+        loading: 'Deploying generic call portal...',
+        success: 'Deployed generic call portal',
+        error: 'Failed to deploy generic call portal',
+      },
+    );
+    return new L1TransactSdk(
+      l1Deployer,
+      l2Deployer,
+      aztecNode,
+      pxe,
+      l2CallPortal,
+      l1CallPortal,
+      l2TokenPortal,
+      l1TokenPortal,
+    );
+  }
+  /**
+   * @deprecated Use `L1TransactSdk.deploy` instead.
+   */
+  static setup = L1TransactSdk.deploy;
+  async l2MintPrivate(token, to, amount) {
+    const { TxStatus } = await import('@aztec/aztec.js');
+    const { secret, secretHash } = await generateSecretAndHash();
+    const tx = token.methods.mint_private(amount, secretHash).send();
+    const receipt = await tx.wait();
+    assert(receipt.status === TxStatus.MINED);
+    return await this.l2RedeemShield({
+      token,
+      wallet: to,
+      amount,
+      secret,
+      txHash: receipt.txHash,
+    });
+  }
+  async l2MintPublic(token, to, amount) {
+    const { TxStatus } = await import('@aztec/aztec.js');
+    const tx = token.methods.mint_public(to, amount).send();
+    const receipt = await tx.wait();
+    assert(receipt.status === TxStatus.MINED);
+    return receipt;
+  }
+  async l2Balance(token, account) {
+    return await token
+      .withWallet(account)
+      .methods.balance_of_private(account.getAddress())
+      .simulate();
+  }
+  async l1MintTokens(minter, to, amount) {
+    const tx = await MockERC20__factory.connect(
+      amount.currency.address,
+      minter,
+    ).mintForTests(to, amount.quotient.toString());
+    return await tx.wait();
+  }
+  async l1Balance(token, account) {
+    return await token.balanceOf(account);
+  }
+  async _addPendingShieldNoteToPXE(
+    token,
+    shieldAmount,
+    secretHash,
+    to,
+    txHash,
+  ) {
+    const { Note, ExtendedNote, Fr } = await import('@aztec/aztec.js');
+    const { TokenContract } = await import('@aztec/noir-contracts.js/Token');
+    const note = new Note([new Fr(shieldAmount), secretHash]);
+    const extendedNote = new ExtendedNote(
+      note,
+      to,
+      token.address,
+      TokenContract.storage.pending_shields.slot,
+      TokenContract.notes.TransparentNote.id,
+      txHash,
+    );
+    await this.pxe.addNote(extendedNote);
+  }
+  async l2RedeemShield({ token, wallet, amount, secret, txHash }) {
+    const { computeSecretHash } = await import('@aztec/aztec.js');
+    await this._addPendingShieldNoteToPXE(
+      token,
+      amount,
+      computeSecretHash(secret),
+      wallet.getAddress(),
+      txHash,
+    );
+    return await token.methods
+      .redeem_shield(wallet.getAddress(), amount, secret)
+      .send()
+      .wait();
+  }
+  async l2RegisterTokenIfNotRegistered(l1Token, l2Token) {
+    if (!l2Token) {
+      assert(l1Token.symbol, 'Token.symbol is required to deploy token on L2');
+      l2Token = await this.#l2DeployToken({
+        ...l1Token,
+        symbol: l1Token.symbol,
+      });
     }
-    async bridgeTokensFromL1ToL2({ l1From, l2To, amounts, }) {
-        const secretForRedeeming = await generateSecretAndHash();
-        const secretForConsumption = await generateSecretAndHash();
-        await this.l1SendTokensToPortalPrivate({
-            l1From,
-            amounts,
-            secretHashForRedeemingMintedNotes: secretForRedeeming.secretHash,
-            secretHashForL2MessageConsumption: secretForConsumption.secretHash,
-        });
-        await this.progressRollup();
-        await this.l2ClaimTokensFromPortalPrivate({
-            l2To,
-            amounts,
-            secretForRedeemingMintedNotes: secretForRedeeming,
-            secretForL2MessageConsumption: secretForConsumption.secret,
-        });
+    const l1TokenAddress = await toEthAddress(l1Token.address);
+    const isRegistered = (
+      await this.l2TokenPortal.methods.token(l1TokenAddress).simulate()
+    ).equals(l2Token.address);
+    if (!isRegistered) {
+      await this.l2TokenPortal.methods
+        .register_token(l1TokenAddress, l2Token)
+        .send()
+        .wait();
     }
-    async bridgeTokensFromL2ToL1({ l2From, l1To, amounts, }) {
-        console.log("Bridging tokens from L2 to L1...");
-        const l2TxReceipt = await this.l2SendTokensToPortalPrivate({
-            l2From,
-            l1To,
-            amounts,
-        });
-        await this.progressRollup();
-        await this.l1ClaimTokensFromPortal({
-            amounts,
-            to: l1To,
-            l2TxReceipt,
-        });
-        console.log("Bridged tokens from L2 to L1");
+    const isMinter = await l2Token.methods
+      .is_minter(this.l2TokenPortal.address)
+      .simulate();
+    if (!isMinter) {
+      await l2Token.methods
+        .set_minter(this.l2TokenPortal.address, true)
+        .send()
+        .wait();
     }
-    async transactOnL1WithL2Tokens({ l2Account, call, amountsIn, amountsOutMin, }) {
-        const { Fr, AztecAddress } = await import("@aztec/aztec.js");
-        const { TokenContract } = await import("@aztec/noir-contracts.js/Token");
-        const { sha256ToField } = await import("@aztec/foundation/crypto");
-        const unshieldNonce = Fr.random();
-        const secretForRedeemingMintedNotes = await generateSecretAndHash();
-        const secretHashForL2MessageConsumption = await generateSecretAndHash();
-        const l1Caller = this.l1Deployer;
-        const l2AmountsInCalldata = await this._l2EncodeAztecTokenAddressesAndAmounts(amountsIn);
-        const l2AmountsOutMinCalldata = await this._l2EncodeAztecTokenAddressesAndAmounts(amountsOutMin);
-        let l2TxReceipt;
-        {
-            console.log("approving L2 tokens...");
-            for (const [i, l2TokenAddress,] of l2AmountsInCalldata.tokensAztecAddresses.entries()) {
-                if (l2TokenAddress.equals(AztecAddress.ZERO)) {
-                    continue;
-                }
-                const l2Token = await TokenContract.at(l2TokenAddress, l2Account);
-                await approveAction(l2Account, this.l2CallPortal.address, l2Token.methods
-                    .unshield(l2Account.getAddress(), this.l2CallPortal, l2AmountsInCalldata.amounts[i], unshieldNonce)
-                    .request());
-            }
-            console.log("Moving tokens to L1...");
-            l2TxReceipt = await this.l2CallPortal
-                .withWallet(l2Account)
-                .methods.generic_call_private(await toEthAddress(call.to), await soliditySha256ToField(call.data), this.l2TokenPortal, l2AmountsInCalldata.tokensEthAddresses, l2AmountsOutMinCalldata.tokensEthAddresses, l2AmountsInCalldata.tokensAztecAddresses, l2AmountsOutMinCalldata.tokensAztecAddresses, l2AmountsInCalldata.amounts, l2AmountsOutMinCalldata.amounts, unshieldNonce, secretForRedeemingMintedNotes.secretHash, secretHashForL2MessageConsumption.secretHash, await toEthAddress(l1Caller))
-                .send()
-                .wait();
-            console.log(`Moved tokens to L1: ${explorerUrl.tx(l2TxReceipt.txHash.toString())}`);
+    return l2Token;
+  }
+  async #l2DeployToken(token) {
+    const { TokenContract } = await import('@aztec/noir-contracts.js/Token');
+    return await deployerCached.l2DeployContractCached(
+      'token_' + token.symbol.toLowerCase(),
+      async (address) => TokenContract.at(address, this.l2Deployer),
+      async () =>
+        TokenContract.deploy(
+          this.l2Deployer,
+          this.l2Deployer.getAddress(),
+          token.symbol,
+          token.symbol,
+          token.decimals,
+        ).send(),
+    );
+  }
+  async progressRollup() {
+    const { EthAddress, AztecAddress } = await import('@aztec/aztec.js');
+    await sleep(10_000);
+    await this.l2TokenPortal.methods
+      .register_token(EthAddress.random(), AztecAddress.random())
+      .send()
+      .wait();
+    await this.l2TokenPortal.methods
+      .register_token(EthAddress.random(), AztecAddress.random())
+      .send()
+      .wait();
+  }
+  async bridgeTokensFromL1ToL2({ l1From, l2To, amounts }) {
+    const secretForRedeeming = await generateSecretAndHash();
+    const secretForConsumption = await generateSecretAndHash();
+    await this.l1SendTokensToPortalPrivate({
+      l1From,
+      amounts,
+      secretHashForRedeemingMintedNotes: secretForRedeeming.secretHash,
+      secretHashForL2MessageConsumption: secretForConsumption.secretHash,
+    });
+    await this.progressRollup();
+    await this.l2ClaimTokensFromPortalPrivate({
+      l2To,
+      amounts,
+      secretForRedeemingMintedNotes: secretForRedeeming,
+      secretForL2MessageConsumption: secretForConsumption.secret,
+    });
+  }
+  async bridgeTokensFromL2ToL1({ l2From, l1To, amounts }) {
+    console.log('Bridging tokens from L2 to L1...');
+    const l2TxReceipt = await this.l2SendTokensToPortalPrivate({
+      l2From,
+      l1To,
+      amounts,
+    });
+    await this.progressRollup();
+    await this.l1ClaimTokensFromPortal({
+      amounts,
+      to: l1To,
+      l2TxReceipt,
+    });
+    console.log('Bridged tokens from L2 to L1');
+  }
+  async transactOnL1WithL2Tokens({
+    l2Account,
+    call,
+    amountsIn,
+    amountsOutMin,
+  }) {
+    const { Fr, AztecAddress } = await import('@aztec/aztec.js');
+    const { TokenContract } = await import('@aztec/noir-contracts.js/Token');
+    const { sha256ToField } = await import('@aztec/foundation/crypto');
+    const unshieldNonce = Fr.random();
+    const secretForRedeemingMintedNotes = await generateSecretAndHash();
+    const secretHashForL2MessageConsumption = await generateSecretAndHash();
+    const l1Caller = this.l1Deployer;
+    const l2AmountsInCalldata =
+      await this._l2EncodeAztecTokenAddressesAndAmounts(amountsIn);
+    const l2AmountsOutMinCalldata =
+      await this._l2EncodeAztecTokenAddressesAndAmounts(amountsOutMin);
+    let l2TxReceipt;
+    {
+      console.log('approving L2 tokens...');
+      for (const [
+        i,
+        l2TokenAddress,
+      ] of l2AmountsInCalldata.tokensAztecAddresses.entries()) {
+        if (l2TokenAddress.equals(AztecAddress.ZERO)) {
+          continue;
         }
-        let amountsOut;
-        {
-            const l1AmountsInCalldata = await this._ethToTokenAddressesAndAmounts(amountsIn);
-            const l1AmountsOutMinCalldata = await this._ethToTokenAddressesAndAmounts(amountsOutMin);
-            const ommSwap = await this.getOutboxMessageMetadataFromReceipt(await outerSha256ToField(this.l2CallPortal.address, this.l1CallPortal, sha256ToField([
-                Buffer.from(ethers.FunctionFragment.from("generic_call_private(address,bytes32,address,address[2],address[2],uint256[2],uint256[2],bytes32,bytes32,address)").selector.substring(2), "hex"),
-                (await toEthAddress(call.to)).toBuffer32(),
-                await soliditySha256ToField(call.data),
-                (await toEthAddress(this.l1TokenPortal)).toBuffer32(),
-                ...(await encodeAddressesToBuffer32(l1AmountsInCalldata.tokens)),
-                ...(await encodeAddressesToBuffer32(l1AmountsOutMinCalldata.tokens)),
-                ...l1AmountsInCalldata.amounts.map((a) => new Fr(a)),
-                ...l1AmountsOutMinCalldata.amounts.map((a) => new Fr(a)),
-                secretForRedeemingMintedNotes.secretHash,
-                secretHashForL2MessageConsumption.secretHash,
-                (await toEthAddress(l1Caller)).toBuffer32(),
-            ])), l2TxReceipt);
-            const ommWithdraw = await this.getOutboxMessageMetadataFromReceipt(await this._tokenPortalGetWithdrawMsgHash(this.l1CallPortal, amountsIn), l2TxReceipt);
-            console.log("Transacting on L1...");
-            const params = {
-                callTo: call.to,
-                callData: call.data,
-                tokenPortal: this.l1TokenPortal,
-                tokensIn: l1AmountsInCalldata.tokens,
-                tokensOut: l1AmountsOutMinCalldata.tokens,
-                amountsIn: l1AmountsInCalldata.amounts,
-                amountsOutMin: l1AmountsOutMinCalldata.amounts,
-                secretHashForRedeemingMintedNotes: secretForRedeemingMintedNotes.secretHash.toString(),
-                secretHashForL2MessageConsumption: secretHashForL2MessageConsumption.secretHash.toString(),
-                ommSwap,
-                ommWithdraw,
-            };
-            const tx = await this.l1CallPortal
-                .connect(l1Caller)
-                .genericCallPrivate(params);
-            const l1Receipt = await tx.wait();
-            assert(l1Receipt, "no receipt for swap on L1");
-            console.log(`Transacted on L1: ${l1Receipt.hash}`);
-            amountsOut = await this.#getGenericCallAmountsOutFromL1Receipt(amountsOutMin, l1Receipt);
-        }
-        await this.progressRollup();
-        await this.l2ClaimTokensFromPortalPrivate({
-            amounts: amountsOut,
-            l2To: l2Account,
-            secretForRedeemingMintedNotes,
-            secretForL2MessageConsumption: secretHashForL2MessageConsumption.secret,
-        });
-    }
-    async #getGenericCallAmountsOutFromL1Receipt(amountsOutMin, l1Receipt) {
-        const erc20Interface = IERC20__factory.createInterface();
-        const erc20Addresses = amountsOutMin.map((a) => a.currency.address.toLowerCase());
-        const decodedLogs = compact(l1Receipt.logs.map((log) => {
-            if (!erc20Addresses.includes(log.address.toLowerCase())) {
-                return undefined;
-            }
-            const e = erc20Interface.parseLog(log);
-            if (!e) {
-                return undefined;
-            }
-            if (e.name !== "Transfer") {
-                return undefined;
-            }
-            return { event: e, log };
-        }));
-        const expectedFrom = await this.l1CallPortal.getAddress();
-        const expectedTo = await this.l1TokenPortal.getAddress();
-        return amountsOutMin.map((a) => {
-            const amountOutLog = decodedLogs.find((x) => isAddressEqual(x?.log.address, a.currency.address) &&
-                isAddressEqual(x?.event.args.from, expectedFrom) &&
-                isAddressEqual(x?.event.args.to, expectedTo));
-            const rawAmountOut = amountOutLog?.event.args.value;
-            assert(rawAmountOut != null, `no amount out log for token ${a.currency.symbol}`);
-            const amountOut = CurrencyAmount.fromRawAmount(a.currency, rawAmountOut.toString());
-            return amountOut;
-        });
-    }
-    async protocol_0x_swap({ l2Account, amountIn, amountOutMin, }) {
-        console.log("Getting 0x quote...");
-        const quote = await get0xQuote((await this.l1Deployer.provider.getNetwork()).chainId, amountIn.currency.address, amountOutMin.currency.address, ethers.getBigInt(amountIn.quotient.toString()));
-        console.log("Got 0x quote", omit(quote, "data"));
-        await this.transactOnL1WithL2Tokens({
-            l2Account,
-            amountsIn: [amountIn],
-            amountsOutMin: [amountOutMin],
-            call: {
-                to: quote.to,
-                data: quote.data,
-            },
-        });
-        console.log("Transacted on L1 with L2 tokens!");
+        const l2Token = await TokenContract.at(l2TokenAddress, l2Account);
+        await approveAction(
+          l2Account,
+          this.l2CallPortal.address,
+          l2Token.methods
+            .unshield(
+              l2Account.getAddress(),
+              this.l2CallPortal,
+              l2AmountsInCalldata.amounts[i],
+              unshieldNonce,
+            )
+            .request(),
+        );
+      }
+      console.log('Moving tokens to L1...');
+      l2TxReceipt = await this.l2CallPortal
+        .withWallet(l2Account)
+        .methods.generic_call_private(
+          await toEthAddress(call.to),
+          await soliditySha256ToField(call.data),
+          this.l2TokenPortal,
+          l2AmountsInCalldata.tokensEthAddresses,
+          l2AmountsOutMinCalldata.tokensEthAddresses,
+          l2AmountsInCalldata.tokensAztecAddresses,
+          l2AmountsOutMinCalldata.tokensAztecAddresses,
+          l2AmountsInCalldata.amounts,
+          l2AmountsOutMinCalldata.amounts,
+          unshieldNonce,
+          secretForRedeemingMintedNotes.secretHash,
+          secretHashForL2MessageConsumption.secretHash,
+          await toEthAddress(l1Caller),
+        )
+        .send()
+        .wait();
+      console.log(
+        `Moved tokens to L1: ${explorerUrl.tx(l2TxReceipt.txHash.toString())}`,
+      );
     }
-    async swapTokensFromL2OnL1MockDex({ l2Account, amountIn, amountOutMin, l1MockDex, }) {
-        await this.transactOnL1WithL2Tokens({
-            l2Account,
-            amountsIn: [amountIn],
-            amountsOutMin: [amountOutMin],
-            call: {
-                to: await l1MockDex.getAddress(),
-                data: l1MockDex.interface.encodeFunctionData("swap", [
-                    amountIn.currency.address,
-                    amountOutMin.currency.address,
-                    amountIn.quotient.toString(),
-                    amountOutMin.quotient.toString(),
-                ]),
-            },
-        });
+    let amountsOut;
+    {
+      const l1AmountsInCalldata = await this._ethToTokenAddressesAndAmounts(
+        amountsIn,
+      );
+      const l1AmountsOutMinCalldata = await this._ethToTokenAddressesAndAmounts(
+        amountsOutMin,
+      );
+      const ommSwap = await this.getOutboxMessageMetadataFromReceipt(
+        await outerSha256ToField(
+          this.l2CallPortal.address,
+          this.l1CallPortal,
+          sha256ToField([
+            Buffer.from(
+              ethers.FunctionFragment.from(
+                'generic_call_private(address,bytes32,address,address[2],address[2],uint256[2],uint256[2],bytes32,bytes32,address)',
+              ).selector.substring(2),
+              'hex',
+            ),
+            (await toEthAddress(call.to)).toBuffer32(),
+            await soliditySha256ToField(call.data),
+            (await toEthAddress(this.l1TokenPortal)).toBuffer32(),
+            ...(await encodeAddressesToBuffer32(l1AmountsInCalldata.tokens)),
+            ...(await encodeAddressesToBuffer32(
+              l1AmountsOutMinCalldata.tokens,
+            )),
+            ...l1AmountsInCalldata.amounts.map((a) => new Fr(a)),
+            ...l1AmountsOutMinCalldata.amounts.map((a) => new Fr(a)),
+            secretForRedeemingMintedNotes.secretHash,
+            secretHashForL2MessageConsumption.secretHash,
+            (await toEthAddress(l1Caller)).toBuffer32(),
+          ]),
+        ),
+        l2TxReceipt,
+      );
+      const ommWithdraw = await this.getOutboxMessageMetadataFromReceipt(
+        await this._tokenPortalGetWithdrawMsgHash(this.l1CallPortal, amountsIn),
+        l2TxReceipt,
+      );
+      console.log('Transacting on L1...');
+      const params = {
+        callTo: call.to,
+        callData: call.data,
+        tokenPortal: this.l1TokenPortal,
+        tokensIn: l1AmountsInCalldata.tokens,
+        tokensOut: l1AmountsOutMinCalldata.tokens,
+        amountsIn: l1AmountsInCalldata.amounts,
+        amountsOutMin: l1AmountsOutMinCalldata.amounts,
+        secretHashForRedeemingMintedNotes:
+          secretForRedeemingMintedNotes.secretHash.toString(),
+        secretHashForL2MessageConsumption:
+          secretHashForL2MessageConsumption.secretHash.toString(),
+        ommSwap,
+        ommWithdraw,
+      };
+      const tx = await this.l1CallPortal
+        .connect(l1Caller)
+        .genericCallPrivate(params);
+      const l1Receipt = await tx.wait();
+      assert(l1Receipt, 'no receipt for swap on L1');
+      console.log(`Transacted on L1: ${l1Receipt.hash}`);
+      amountsOut = await this.#getGenericCallAmountsOutFromL1Receipt(
+        amountsOutMin,
+        l1Receipt,
+      );
     }
-    async l1SendTokensToPortalPrivate({ l1From, amounts, secretHashForRedeemingMintedNotes, secretHashForL2MessageConsumption, }) {
-        console.log("approving on L1");
-        for (const amount of amounts) {
-            const tokenContract = IERC20__factory.connect(amount.currency.address, l1From);
-            const allowance = await tokenContract.allowance(l1From, this.l1TokenPortal);
-            if (allowance >= ethers.getBigInt(amount.quotient.toString())) {
-                continue;
-            }
-            await (await tokenContract.approve(this.l1TokenPortal, ethers.MaxUint256, {
-                nonce: await l1From.provider.getTransactionCount(l1From),
-            })).wait();
+    await this.progressRollup();
+    await this.l2ClaimTokensFromPortalPrivate({
+      amounts: amountsOut,
+      l2To: l2Account,
+      secretForRedeemingMintedNotes,
+      secretForL2MessageConsumption: secretHashForL2MessageConsumption.secret,
+    });
+  }
+  async #getGenericCallAmountsOutFromL1Receipt(amountsOutMin, l1Receipt) {
+    const erc20Interface = IERC20__factory.createInterface();
+    const erc20Addresses = amountsOutMin.map((a) =>
+      a.currency.address.toLowerCase(),
+    );
+    const decodedLogs = compact(
+      l1Receipt.logs.map((log) => {
+        if (!erc20Addresses.includes(log.address.toLowerCase())) {
+          return undefined;
         }
-        console.log("approved on L1");
-        const amountsCalldata = await this._ethToTokenAddressesAndAmounts(amounts);
-        console.log("Depositing tokens to L2 portal privately...");
-        const tx = await this.l1TokenPortal
-            .connect(l1From)
-            .depositToAztecPrivate(secretHashForRedeemingMintedNotes.toString(), secretHashForL2MessageConsumption.toString(), amountsCalldata.tokens, amountsCalldata.amounts);
-        console.log("Deposit tx sent. Waiting...");
-        const receipt = await tx.wait();
-        assert(receipt, "no receipt");
-        console.log("Deposited");
-        return receipt;
-    }
-    async getOutboxMessageMetadataFromReceipt(msgHash, l2TxReceipt) {
-        const [l2ToL1MessageIndex, siblingPath] = await this.aztecNode.getL2ToL1MessageMembershipWitness(l2TxReceipt.blockNumber, msgHash);
-        assert(l2TxReceipt.blockNumber != null, "no block number in receipt");
-        return {
-            l2BlockNumber: ethers.getBigInt(l2TxReceipt.blockNumber),
-            leafIndex: l2ToL1MessageIndex,
-            path: siblingPath.toFields().map((field) => field.toString()),
-        };
-    }
-    async l1ClaimTokensFromPortal({ to, amounts, l2TxReceipt, }) {
-        const l1TokensCalldata = await this._ethToTokenAddressesAndAmounts(amounts);
-        console.log("Claiming tokens on L1...");
-        const msgHash = await this._tokenPortalGetWithdrawMsgHash(to, amounts);
-        const tx = await this.l1TokenPortal
-            .connect(to)
-            .withdraw(to, true, l1TokensCalldata.tokens, l1TokensCalldata.amounts, await this.getOutboxMessageMetadataFromReceipt(msgHash, l2TxReceipt));
-        await tx.wait();
-        console.log("Claimed tokens on L1");
-    }
-    async l2SendTokensToPortalPrivate({ l2From, l1To, amounts, }) {
-        const { Fr } = await import("@aztec/aztec.js");
-        const { TokenContract } = await import("@aztec/noir-contracts.js/Token");
-        const l1ToAddress = await toEthAddress(l1To);
-        const burnNonce = Fr.random();
-        const l2TokensCalldata = await this._l2EncodeAztecTokenAddressesAndAmounts(amounts);
-        for (const [i, tokenAddress,] of l2TokensCalldata.tokensAztecAddresses.entries()) {
-            const token = await TokenContract.at(tokenAddress, l2From);
-            await approveAction(l2From, this.l2TokenPortal.address, token.methods
-                .burn(l2From.getAddress(), l2TokensCalldata.amounts[i], burnNonce)
-                .request());
+        const e = erc20Interface.parseLog(log);
+        if (!e) {
+          return undefined;
         }
-        console.log("Sending tokens to L2 portal to be consumed privately");
-        const receipt = await this.l2TokenPortal
-            .withWallet(l2From)
-            .methods.exit_to_l1_private(l1ToAddress, l1ToAddress, burnNonce, l2TokensCalldata.tokensEthAddresses, l2TokensCalldata.tokensAztecAddresses, l2TokensCalldata.amounts)
-            .send()
-            .wait();
-        console.log("Sent tokens to L2 portal");
-        return receipt;
-    }
-    async l2ClaimTokensFromPortalPrivate({ l2To, amounts, secretForRedeemingMintedNotes, secretForL2MessageConsumption, }) {
-        const { TxStatus } = await import("@aztec/aztec.js");
-        const { TokenContract } = await import("@aztec/noir-contracts.js/Token");
-        const l2TokensCalldata = await this._l2EncodeAztecTokenAddressesAndAmounts(amounts);
-        console.log("claiming on L2...");
-        const consumptionReceipt = await this.l2TokenPortal.methods
-            .claim_private(secretForRedeemingMintedNotes.secretHash, secretForL2MessageConsumption, l2TokensCalldata.tokensEthAddresses, l2TokensCalldata.amounts)
-            .send()
-            .wait();
-        assert(consumptionReceipt.status === TxStatus.MINED, "tx not mined");
-        console.log(`claimed on L2: ${explorerUrl.tx(consumptionReceipt.txHash.toString())}`);
-        console.log("redeeming on L2...");
-        for (const [i, token] of l2TokensCalldata.tokensAztecAddresses.entries()) {
-            if (token.isZero()) {
-                continue;
-            }
-            const tokenContract = await TokenContract.at(token, l2To);
-            await this.l2RedeemShield({
-                token: tokenContract,
-                wallet: l2To,
-                amount: l2TokensCalldata.amounts[i],
-                secret: secretForRedeemingMintedNotes.secret,
-                txHash: consumptionReceipt.txHash,
-            });
+        if (e.name !== 'Transfer') {
+          return undefined;
         }
-        console.log("redeemed on L2");
+        return { event: e, log };
+      }),
+    );
+    const expectedFrom = await this.l1CallPortal.getAddress();
+    const expectedTo = await this.l1TokenPortal.getAddress();
+    return amountsOutMin.map((a) => {
+      const amountOutLog = decodedLogs.find(
+        (x) =>
+          isAddressEqual(x?.log.address, a.currency.address) &&
+          isAddressEqual(x?.event.args.from, expectedFrom) &&
+          isAddressEqual(x?.event.args.to, expectedTo),
+      );
+      const rawAmountOut = amountOutLog?.event.args.value;
+      assert(
+        rawAmountOut != null,
+        `no amount out log for token ${a.currency.symbol}`,
+      );
+      const amountOut = CurrencyAmount.fromRawAmount(
+        a.currency,
+        rawAmountOut.toString(),
+      );
+      return amountOut;
+    });
+  }
+  async protocol_0x_swap({ l2Account, amountIn, amountOutMin }) {
+    console.log('Getting 0x quote...');
+    const quote = await get0xQuote(
+      (
+        await this.l1Deployer.provider.getNetwork()
+      ).chainId,
+      amountIn.currency.address,
+      amountOutMin.currency.address,
+      ethers.getBigInt(amountIn.quotient.toString()),
+    );
+    console.log('Got 0x quote', omit(quote, 'data'));
+    await this.transactOnL1WithL2Tokens({
+      l2Account,
+      amountsIn: [amountIn],
+      amountsOutMin: [amountOutMin],
+      call: {
+        to: quote.to,
+        data: quote.data,
+      },
+    });
+    console.log('Transacted on L1 with L2 tokens!');
+  }
+  async swapTokensFromL2OnL1MockDex({
+    l2Account,
+    amountIn,
+    amountOutMin,
+    l1MockDex,
+  }) {
+    await this.transactOnL1WithL2Tokens({
+      l2Account,
+      amountsIn: [amountIn],
+      amountsOutMin: [amountOutMin],
+      call: {
+        to: await l1MockDex.getAddress(),
+        data: l1MockDex.interface.encodeFunctionData('swap', [
+          amountIn.currency.address,
+          amountOutMin.currency.address,
+          amountIn.quotient.toString(),
+          amountOutMin.quotient.toString(),
+        ]),
+      },
+    });
+  }
+  async l1SendTokensToPortalPrivate({
+    l1From,
+    amounts,
+    secretHashForRedeemingMintedNotes,
+    secretHashForL2MessageConsumption,
+  }) {
+    console.log('approving on L1');
+    for (const amount of amounts) {
+      const tokenContract = IERC20__factory.connect(
+        amount.currency.address,
+        l1From,
+      );
+      const allowance = await tokenContract.allowance(
+        l1From,
+        this.l1TokenPortal,
+      );
+      if (allowance >= ethers.getBigInt(amount.quotient.toString())) {
+        continue;
+      }
+      await (
+        await tokenContract.approve(this.l1TokenPortal, ethers.MaxUint256, {
+          nonce: await l1From.provider.getTransactionCount(l1From),
+        })
+      ).wait();
     }
-    async _ethToTokenAddressesAndAmounts(amounts) {
-        const tokens = amounts.map((a) => a.currency.address);
-        const tokensPadded = safeArrayPadEnd(tokens, MAX_TOKENS_SIZE, ethers.ZeroAddress);
-        const amounts_ = amounts.map((a) => ethers.getBigInt(a.quotient.toString()));
-        const amountsPadded = safeArrayPadEnd(amounts_, MAX_TOKENS_SIZE, 0n);
-        return { tokens: tokensPadded, amounts: amountsPadded };
-    }
-    async _l2EncodeAztecTokenAddressesAndAmounts(amounts) {
-        const { EthAddress, AztecAddress } = await import("@aztec/aztec.js");
-        const tokens = await Promise.all(amounts.map(async (a) => (await this.l2TokenPortal.methods
-            .token(await toEthAddress(a.currency.address))
-            .simulate())));
-        const tokensPadded = safeArrayPadEnd(tokens, MAX_TOKENS_SIZE, AztecAddress.ZERO);
-        const tokensEthAddresses = safeArrayPadEnd(await Promise.all(amounts.map(async (a) => toEthAddress(a.currency.address))), MAX_TOKENS_SIZE, EthAddress.ZERO);
-        const amountsPadded = safeArrayPadEnd(amounts.map((a) => ethers.getBigInt(a.quotient.toString())), MAX_TOKENS_SIZE, 0n);
-        return {
-            tokensAztecAddresses: tokensPadded,
-            tokensEthAddresses,
-            amounts: amountsPadded,
-        };
+    console.log('approved on L1');
+    const amountsCalldata = await this._ethToTokenAddressesAndAmounts(amounts);
+    console.log('Depositing tokens to L2 portal privately...');
+    const tx = await this.l1TokenPortal
+      .connect(l1From)
+      .depositToAztecPrivate(
+        secretHashForRedeemingMintedNotes.toString(),
+        secretHashForL2MessageConsumption.toString(),
+        amountsCalldata.tokens,
+        amountsCalldata.amounts,
+      );
+    console.log('Deposit tx sent. Waiting...');
+    const receipt = await tx.wait();
+    assert(receipt, 'no receipt');
+    console.log('Deposited');
+    return receipt;
+  }
+  async getOutboxMessageMetadataFromReceipt(msgHash, l2TxReceipt) {
+    const [l2ToL1MessageIndex, siblingPath] =
+      await this.aztecNode.getL2ToL1MessageMembershipWitness(
+        l2TxReceipt.blockNumber,
+        msgHash,
+      );
+    assert(l2TxReceipt.blockNumber != null, 'no block number in receipt');
+    return {
+      l2BlockNumber: ethers.getBigInt(l2TxReceipt.blockNumber),
+      leafIndex: l2ToL1MessageIndex,
+      path: siblingPath.toFields().map((field) => field.toString()),
+    };
+  }
+  async l1ClaimTokensFromPortal({ to, amounts, l2TxReceipt }) {
+    const l1TokensCalldata = await this._ethToTokenAddressesAndAmounts(amounts);
+    console.log('Claiming tokens on L1...');
+    const msgHash = await this._tokenPortalGetWithdrawMsgHash(to, amounts);
+    console.log('msgHash :', msgHash);
+    const tx = await this.l1TokenPortal
+      .connect(to)
+      .withdraw(
+        to,
+        true,
+        l1TokensCalldata.tokens,
+        l1TokensCalldata.amounts,
+        await this.getOutboxMessageMetadataFromReceipt(msgHash, l2TxReceipt),
+      );
+    console.log('tx :', tx);
+    await tx.wait();
+    console.log('Claimed tokens on L1');
+  }
+  async l2SendTokensToPortalPrivate({ l2From, l1To, amounts }) {
+    const { Fr } = await import('@aztec/aztec.js');
+    const { TokenContract } = await import('@aztec/noir-contracts.js/Token');
+    const l1ToAddress = await toEthAddress(l1To);
+    const burnNonce = Fr.random();
+    const l2TokensCalldata = await this._l2EncodeAztecTokenAddressesAndAmounts(
+      amounts,
+    );
+    for (const [
+      i,
+      tokenAddress,
+    ] of l2TokensCalldata.tokensAztecAddresses.entries()) {
+      if (tokenAddress.isZero()) {
+        continue;
+      }
+      const token = await TokenContract.at(tokenAddress, l2From);
+      await approveAction(
+        l2From,
+        this.l2TokenPortal.address,
+        token.methods
+          .burn(l2From.getAddress(), l2TokensCalldata.amounts[i], burnNonce)
+          .request(),
+      );
     }
-    async _tokenPortalGetWithdrawMsgHash(to, amounts) {
-        const { Fr } = await import("@aztec/aztec.js");
-        const { sha256ToField } = await import("@aztec/foundation/crypto");
-        const ethTokensCalldata = await this._ethToTokenAddressesAndAmounts(amounts);
-        return await outerSha256ToField(this.l2TokenPortal.address, this.l1TokenPortal, sha256ToField([
-            Buffer.from(ethers.FunctionFragment.from("withdraw(address,address,address[2],uint256[2])").selector.substring(2), "hex"),
-            (await toEthAddress(to)).toBuffer32(),
-            (await toEthAddress(to)).toBuffer32(),
-            ...(await encodeAddressesToBuffer32(ethTokensCalldata.tokens)),
-            ...ethTokensCalldata.amounts.map((a) => new Fr(a).toBuffer()),
-        ]));
+    console.log('Sending tokens to L2 portal to be consumed privately');
+    const receipt = await this.l2TokenPortal
+      .withWallet(l2From)
+      .methods.exit_to_l1_private(
+        l1ToAddress,
+        l1ToAddress,
+        burnNonce,
+        l2TokensCalldata.tokensEthAddresses,
+        l2TokensCalldata.tokensAztecAddresses,
+        l2TokensCalldata.amounts,
+      )
+      .send()
+      .wait();
+    console.log('Sent tokens to L2 portal');
+    return receipt;
+  }
+  async l2ClaimTokensFromPortalPrivate({
+    l2To,
+    amounts,
+    secretForRedeemingMintedNotes,
+    secretForL2MessageConsumption,
+  }) {
+    const { TxStatus } = await import('@aztec/aztec.js');
+    const { TokenContract } = await import('@aztec/noir-contracts.js/Token');
+    const l2TokensCalldata = await this._l2EncodeAztecTokenAddressesAndAmounts(
+      amounts,
+    );
+    console.log('claiming on L2...');
+    const consumptionReceipt = await this.l2TokenPortal.methods
+      .claim_private(
+        secretForRedeemingMintedNotes.secretHash,
+        secretForL2MessageConsumption,
+        l2TokensCalldata.tokensEthAddresses,
+        l2TokensCalldata.amounts,
+      )
+      .send()
+      .wait();
+    assert(consumptionReceipt.status === TxStatus.MINED, 'tx not mined');
+    console.log(
+      `claimed on L2: ${explorerUrl.tx(consumptionReceipt.txHash.toString())}`,
+    );
+    console.log('redeeming on L2...');
+    for (const [i, token] of l2TokensCalldata.tokensAztecAddresses.entries()) {
+      if (token.isZero()) {
+        continue;
+      }
+      const tokenContract = await TokenContract.at(token, l2To);
+      await this.l2RedeemShield({
+        token: tokenContract,
+        wallet: l2To,
+        amount: l2TokensCalldata.amounts[i],
+        secret: secretForRedeemingMintedNotes.secret,
+        txHash: consumptionReceipt.txHash,
+      });
     }
+    console.log('redeemed on L2');
+  }
+  async _ethToTokenAddressesAndAmounts(amounts) {
+    const tokens = amounts.map((a) => a.currency.address);
+    const tokensPadded = safeArrayPadEnd(
+      tokens,
+      MAX_TOKENS_SIZE,
+      ethers.ZeroAddress,
+    );
+    const amounts_ = amounts.map((a) =>
+      ethers.getBigInt(a.quotient.toString()),
+    );
+    const amountsPadded = safeArrayPadEnd(amounts_, MAX_TOKENS_SIZE, 0n);
+    return { tokens: tokensPadded, amounts: amountsPadded };
+  }
+  async _l2EncodeAztecTokenAddressesAndAmounts(amounts) {
+    const { EthAddress, AztecAddress } = await import('@aztec/aztec.js');
+    const tokens = await Promise.all(
+      amounts.map(
+        async (a) =>
+          await this.l2TokenPortal.methods
+            .token(await toEthAddress(a.currency.address))
+            .simulate(),
+      ),
+    );
+    const tokensPadded = safeArrayPadEnd(
+      tokens,
+      MAX_TOKENS_SIZE,
+      AztecAddress.ZERO,
+    );
+    const tokensEthAddresses = safeArrayPadEnd(
+      await Promise.all(
+        amounts.map(async (a) => toEthAddress(a.currency.address)),
+      ),
+      MAX_TOKENS_SIZE,
+      EthAddress.ZERO,
+    );
+    const amountsPadded = safeArrayPadEnd(
+      amounts.map((a) => ethers.getBigInt(a.quotient.toString())),
+      MAX_TOKENS_SIZE,
+      0n,
+    );
+    return {
+      tokensAztecAddresses: tokensPadded,
+      tokensEthAddresses,
+      amounts: amountsPadded,
+    };
+  }
+  async _tokenPortalGetWithdrawMsgHash(to, amounts) {
+    console.log('_tokenPortalGetWithdrawMsgHash');
+    const { Fr } = await import('@aztec/aztec.js');
+    const { sha256ToField } = await import('@aztec/foundation/crypto');
+    const ethTokensCalldata = await this._ethToTokenAddressesAndAmounts(
+      amounts,
+    );
+    console.log('ethTokensCalldata: ', ethTokensCalldata);
+    return await outerSha256ToField(
+      this.l2TokenPortal.address,
+      this.l1TokenPortal,
+      sha256ToField([
+        Buffer.from(
+          ethers.FunctionFragment.from(
+            'withdraw(address,address,address[2],uint256[2])',
+          ).selector.substring(2),
+          'hex',
+        ),
+        (await toEthAddress(to)).toBuffer32(),
+        (await toEthAddress(to)).toBuffer32(),
+        ...(await encodeAddressesToBuffer32(ethTokensCalldata.tokens)),
+        ...ethTokensCalldata.amounts.map((a) => new Fr(a).toBuffer()),
+      ]),
+    );
+  }
 }
 async function generateSecretAndHash() {
-    const { Fr, computeSecretHash } = await import("@aztec/aztec.js");
-    const secret = Fr.random();
-    const secretHash = computeSecretHash(secret);
-    console.log("secret & hash", secret.toString(), secretHash.toString());
-    return { secret, secretHash };
+  const { Fr, computeSecretHash } = await import('@aztec/aztec.js');
+  const secret = Fr.random();
+  const secretHash = computeSecretHash(secret);
+  console.log('secret & hash', secret.toString(), secretHash.toString());
+  return { secret, secretHash };
 }
 async function approveAction(wallet, to, request) {
-    await wallet.createAuthWit({ caller: to, action: request });
+  await wallet.createAuthWit({ caller: to, action: request });
 }
 async function soliditySha256ToField(data) {
-    const { sha256ToField } = await import("@aztec/foundation/crypto");
-    return sha256ToField([Buffer.from(ethers.getBytes(data))]);
+  const { sha256ToField } = await import('@aztec/foundation/crypto');
+  return sha256ToField([Buffer.from(ethers.getBytes(data))]);
 }
 async function toEthAddress(address) {
-    const { EthAddress } = await import("@aztec/aztec.js");
-    return EthAddress.fromString(await ethers.resolveAddress(address));
+  const { EthAddress } = await import('@aztec/aztec.js');
+  return EthAddress.fromString(await ethers.resolveAddress(address));
 }
 async function outerSha256ToField(l2Portal, l1Portal, contentHash) {
-    const { Fr } = await import("@aztec/aztec.js");
-    const { sha256ToField } = await import("@aztec/foundation/crypto");
-    return sha256ToField([
-        l2Portal.toBuffer(),
-        new Fr(1).toBuffer(), // aztec version
-        (await toEthAddress(l1Portal)).toBuffer32(),
-        new Fr((await l1Portal.runner.provider.getNetwork()).chainId).toBuffer(), // chain id
-        contentHash,
-    ]);
+  const { Fr } = await import('@aztec/aztec.js');
+  const { sha256ToField } = await import('@aztec/foundation/crypto');
+  return sha256ToField([
+    l2Portal.toBuffer(),
+    new Fr(1).toBuffer(), // aztec version
+    (await toEthAddress(l1Portal)).toBuffer32(),
+    new Fr((await l1Portal.runner.provider.getNetwork()).chainId).toBuffer(), // chain id
+    contentHash,
+  ]);
 }
 async function encodeAddressesToBuffer32(addresses) {
-    return await Promise.all(addresses.map(async (address) => (await toEthAddress(address)).toBuffer32()));
+  return await Promise.all(
+    addresses.map(async (address) =>
+      (await toEthAddress(address)).toBuffer32(),
+    ),
+  );
 }
 function safeArrayPadEnd(arr, length, padValue) {
-    if (arr.length > length) {
-        throw new Error("array too long");
-    }
-    const padding = Array(length - arr.length).fill(padValue);
-    return [...arr, ...padding];
+  if (arr.length > length) {
+    throw new Error('array too long');
+  }
+  const padding = Array(length - arr.length).fill(padValue);
+  return [...arr, ...padding];
 }
 async function get0xQuote(chainId, tokenIn, tokenOut, amountIn) {
-    const params = {
-        // Not all token symbols are supported. The address of the token should be used instead.
-        sellToken: tokenIn,
-        buyToken: tokenOut,
-        sellAmount: amountIn.toString(),
-        // takerAddress: await wallet.getAddress(),
-    };
-    const apiBase = {
-        1: "https://api.0x.org",
-        31337: "https://sepolia.api.0x.org", // forked
-        11155111: "https://sepolia.api.0x.org",
-    }[ethers.getNumber(chainId)];
-    assert(apiBase, `unsupported chain id: ${chainId}`);
-    const headers = { "0x-api-key": "4e96a696-0498-4252-b877-a9cbf2a224ea" };
-    const response = await fetch(`${apiBase}/swap/v1/quote?${qs.stringify(params)}`, { headers });
-    if (!response.ok) {
-        throw new Error(await response.text());
-    }
-    const data = await response.json();
-    return data;
+  const params = {
+    // Not all token symbols are supported. The address of the token should be used instead.
+    sellToken: tokenIn,
+    buyToken: tokenOut,
+    sellAmount: amountIn.toString(),
+    // takerAddress: await wallet.getAddress(),
+  };
+  const apiBase = {
+    1: 'https://api.0x.org',
+    31337: 'https://sepolia.api.0x.org', // forked
+    11155111: 'https://sepolia.api.0x.org',
+  }[ethers.getNumber(chainId)];
+  assert(apiBase, `unsupported chain id: ${chainId}`);
+  const headers = { '0x-api-key': '4e96a696-0498-4252-b877-a9cbf2a224ea' };
+  const response = await fetch(
+    `${apiBase}/swap/v1/quote?${qs.stringify(params)}`,
+    { headers },
+  );
+  if (!response.ok) {
+    throw new Error(await response.text());
+  }
+  const data = await response.json();
+  return data;
 }
 const defaultLogger = {
-    promise: async (promise, msgs) => {
-        console.log(msgs.loading);
-        try {
-            const result = await promise;
-            console.log(msgs.success);
-            return result;
-        }
-        catch (error) {
-            console.error(msgs.error, error);
-            throw error;
-        }
-    },
+  promise: async (promise, msgs) => {
+    console.log(msgs.loading);
+    try {
+      const result = await promise;
+      console.log(msgs.success);
+      return result;
+    } catch (error) {
+      console.error(msgs.error, error);
+      throw error;
+    }
+  },
 };
